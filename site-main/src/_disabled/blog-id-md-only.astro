---
import PostLayout from '@/layouts/BlogPost.astro'

// Type-only import to satisfy `verbatimModuleSyntax`/build
import type { BlogCollectionPost } from '../lib/sanity'
import { getSanityPosts } from '../lib/sanity'

import { marked } from 'marked'
import type { Tokens } from 'marked'
import markedKatex from 'marked-katex-extension'
import markedFootnote from 'marked-footnote'
import { gfmHeadingId } from 'marked-gfm-heading-id'
import { createHighlighter } from 'shiki'
import { 
  transformerNotationDiff, 
  transformerNotationHighlight, 
  transformerNotationWordHighlight 
} from '@shikijs/transformers'
import GithubSlugger from 'github-slugger'

export const prerender = true

export async function getStaticPaths() {
  const posts: BlogCollectionPost[] = await getSanityPosts()

  return posts.map((post) => ({
    params: { id: post.slug },
    props: {
      post,
      posts
    }
  }))
}

const { post, posts } = Astro.props as { post: BlogCollectionPost; posts: BlogCollectionPost[] }

// --- SHIKI SETUP ---
const highlighter = await createHighlighter({
  themes: ['github-dark', 'github-light'],
  langs: ['js', 'ts', 'markdown', 'html', 'css', 'python', 'bash', 'json', 'astro', 'shell', 'diff', 'txt']
})

const renderer = {
  code(token: Tokens.Code) {
    const code = token.text
    const requestedLang = token.lang || 'plaintext'
    const language = highlighter.getLoadedLanguages().includes(requestedLang)
      ? requestedLang
      : 'plaintext'

    const html = highlighter.codeToHtml(code, {
      lang: language,
      themes: {
        light: 'github-light',
        dark: 'github-dark'
      },
      defaultColor: false,
      transformers: [
        transformerNotationDiff(),
        transformerNotationHighlight(),
        transformerNotationWordHighlight(),
        {
          name: 'add-line-classes',
          code(root) {
            const pre = root.children.find(c => c.type === 'element' && c.tagName === 'pre')
            if (pre?.type === 'element') {
              pre.properties.style = 'background-color: transparent !important;'
              const codeEl = pre.children.find(c => c.type === 'element' && c.tagName === 'code')
              if (codeEl?.type === 'element') {
                codeEl.children.forEach(line => {
                  if (line.type === 'element' && line.tagName === 'span') {
                    line.properties.className ||= []
                    ;(line.properties.className as string[]).push('line')
                  }
                })
              }
            }
          }
        }
      ]
    })

    return `
      <figure class="astro-code relative group">
        ${html}
        <div class="language absolute text-sm text-foreground px-3 py-1 top-2 right-16 opacity-50 group-hover:opacity-0 transition-opacity uppercase">
          ${language}
        </div>
        <button class="copy absolute top-2 right-2 p-1 rounded border border-border bg-muted hover:bg-primary/10 transition-all" title="Copy code">
          <span class="ready">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-4"><rect width="14" height="14" x="8" y="8" rx="2" ry="2"/><path d="M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2"/></svg>
          </span>
          <span class="success hidden">
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="size-4 stroke-green-500"><polyline points="20 6 9 17 4 12"/></svg>
          </span>
        </button>
      </figure>
    `
  }
}

// --- MARKED SETUP ---
marked.use({ renderer })
marked.use(markedKatex({ throwOnError: false }))
marked.use(gfmHeadingId())
marked.use(markedFootnote())

const htmlContent = marked.parse(post.body || '')

// --- TOC ---
function extractHeadings(markdown: string) {
  const slugger = new GithubSlugger()
  return marked.lexer(markdown)
    .filter((token) => token.type === 'heading')
    .map((token: any) => ({
      depth: token.depth,
      text: token.text,
      slug: slugger.slug(token.text)
    }))
}

const headings = extractHeadings(post.body || '')
---

<PostLayout 
  {post} 
  {posts} 
  {headings} 
  remarkPluginFrontmatter={{ minutesRead: post.data.minutesRead }}
>
  <article class="prose prose-pure dark:prose-invert max-w-none">
    <div set:html={htmlContent} />
  </article>
</PostLayout>
